---
title: "simulation-tests"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simulation-tests}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(TriLLIEM)
library(tidyverse); theme_set(theme_bw())
library(parallel)
library(knitr)
```

We simulate data under the following models:

```{r}
## Include C+M, C+M:E, Im + C
## What happens if we model MS or MaS data as HWE (not a test), popstrat as HWE
## Talk about HWE for lab meeting
conditions <- expand.grid(
  maf = 0.3,
  R = c(1, 1.15),
  S = 1,
  V = c(1, 1.5, 1.6),
  mtCoef = c(0.85, 1, 1.15),
  Im = c(1, 1.2, 1.4),
  If = c(1, 1.2, 1.4),
  includeE = c(FALSE, TRUE),
  Einteraction = c("Im", "If"),
  prE = c(0.3, 0.5),
  includeControl = c(FALSE, TRUE),
  prControl = 0.5,
  stringsAsFactors = FALSE
) %>%
  filter(
    !(!includeE & !(Einteraction == "Im" & V == 1 & prE == 0.3)),
    (R == 1) + (S == 1) + (V == 1) + (Im == 1) + (If == 1) >= 4,
    !(If != 1 & (Im != 1 | Einteraction == "Im")),
    !(Im != 1 & Einteraction == "If")
  )

head(conditions)
```

```{r data_read, cache = TRUE}
tril_results <- readRDS("All_results/TriLLIEM_res.RDS")
hap_results <- readRDS("All_results/Haplin_res.RDS")
emim_results <- readRDS("All_results/EMIM_res.RDS")
```

Create boxplots:

```{r}
## Add a table with avg of all estimates each condition
## % bias (true - est)/true, if exceeds threshold then plot
# Compare with EMIM and Haplin errors, check why they look similar but bias is a little different
# Check power for imprinting, with diff eff sizes
# If Im is in the model, don't include E:M or M (but M works, although could be overparameterized)
get_bias <- function(results, C, M, V, Im, If){
  if(is.null(results)) return(NULL)
  
    point_est_means <- 
      mapply(
        FUN = function(mat){
          mat[,1]
        },
        mat = results
      )
    
    elements <- intersect(row.names(point_est_means), c("C", "M", "E:M", "E:Im", "E:If", "Im", "If"))
    
    point_est_means <- point_est_means %>%
      t() %>%
      colMeans() %>%
      exp() %>%
      .[elements]
    
    true_vals <- c(C = C, M = M, "E:M" = V, "E:Im" = V, "E:If" = V, Im = Im, If = If)[elements]
    bias <- (true_vals - point_est_means)/true_vals
    return(bias)
}

get_bias_emim <- function(results, C, M, V, Im, If){
  if(is.null(results)) return(NULL)
  
    point_est_means <- 
      mapply(
        FUN = function(mat){
          eff <- mat$effects
          return(eff[eff != 1])
        },
        mat = results
      )
    
    elements <- intersect(row.names(point_est_means), c("C", "M", "M[E=1]/M[E=0]", "Im", "If"))
    
    point_est_means <- point_est_means %>%
      t() %>%
      colMeans() %>%
      .[elements]
    
    true_vals <- c(C = C, M = M, "M[E=1]/M[E=0]" = V, Im = Im, If = If)[elements]
    bias <- (true_vals - point_est_means)/true_vals
    return(bias)
  }

mt <- c("HWE", "MS", "MaS")

bias_trill_nostrat <-
  lapply(
    X = 1:3,
    FUN = function(j) {
      df <- lapply(
        X = 1:nrow(conditions),
        FUN = function(i, j) {
          with(conditions,
               get_bias(
                 results = tril_results[[j]][[i]][["nostrat"]],
                 C = R[i],
                 M = S[i],
                 V = V[i],
                 Im = Im[i],
                 If = If[i]
               ))
        },
        j = j
      ) %>%
        lapply(as.data.frame.list) %>%
        bind_rows()
        # rename(
        #   paste0("bias_C_", mt[[j]]) = "C",
        #   paste0("bias_M_", mt[[j]]) = "M",
        #   paste0("bias_E:Im_", mt[[j]]) = "E.Im",
        #   paste0("bias_E:If_", mt[[j]]) = "E.If",
        #   paste0("bias_Im_", mt[[j]]) = "Im",
        #   paste0("bias_If_", mt[[j]]) = "If"
        # )
      colnames(df) <- paste0("bias_trill_", colnames(df), "_", mt[[j]])
      return(df)
    }
  )

temp_MaS_df <- data.frame(
  bias_trill_C_MaS = rep(NA, nrow(conditions)),
  bias_trill_M_MaS = rep(NA, nrow(conditions)),
  bias_trill_Im_MaS = rep(NA, nrow(conditions)),
  bias_trill_E.Im_MaS = rep(NA, nrow(conditions)),
  bias_trill_If_MaS = rep(NA, nrow(conditions)),
  bias_trill_E.If_MaS = rep(NA, nrow(conditions))
)

temp_MaS_df[which(conditions$includeControl),] <- bias_trill_nostrat[[3]]
bias_trill_nostrat[[3]] <- temp_MaS_df

bias_trill_nostrat <- 
  bias_trill_nostrat %>%
  lapply(as.data.frame.list) %>%
  bind_cols()

conditions_with_trill_nostrat <- bind_cols(conditions, bias_trill_nostrat)

bias_trill_strat <-
  lapply(
    X = 1:3,
    FUN = function(j) {
      df <- lapply(
        X = 1:nrow(conditions),
        FUN = function(i, j) {
          with(conditions,
               get_bias(
                 results = tril_results[[j]][[i]][["strat"]],
                 C = R[i],
                 M = S[i],
                 V = V[i],
                 Im = Im[i],
                 If = If[i]
               ))
        },
        j = j
      ) %>%
        lapply(as.data.frame.list) %>%
        bind_rows()
        # rename(
        #   paste0("bias_C_", mt[[j]]) = "C",
        #   paste0("bias_M_", mt[[j]]) = "M",
        #   paste0("bias_E:Im_", mt[[j]]) = "E.Im",
        #   paste0("bias_E:If_", mt[[j]]) = "E.If",
        #   paste0("bias_Im_", mt[[j]]) = "Im",
        #   paste0("bias_If_", mt[[j]]) = "If"
        # )
      colnames(df) <- paste0("bias_trill_strat_", colnames(df), "_", mt[[j]])
      return(df)
    }
  )

strats <- nrow(conditions %>% filter(includeE))

temp_MaS_df <- data.frame(
  bias_trill_strat_C_MaS = rep(NA, strats),
  bias_trill_strat_M_MaS = rep(NA, strats),
  bias_trill_strat_Im_MaS = rep(NA, strats),
  bias_trill_strat_E.M_MaS = rep(NA, strats),
  bias_trill_strat_E.Im_MaS = rep(NA, strats),
  bias_trill_strat_If_MaS = rep(NA, strats),
  bias_trill_strat_E.If_MaS = rep(NA, strats)
)

temp_MaS_df[which(conditions$includeControl & conditions$includeE),] <- bias_trill_strat[[3]]
bias_trill_strat[[3]] <- temp_MaS_df

bias_trill_strat <- 
  bias_trill_strat %>%
  lapply(as.data.frame.list) %>%
  bind_cols()

conditions_with_trill <- bind_cols(conditions_with_trill_nostrat, bias_trill_strat)

bias_emim <-
  lapply(
    X = 1:3,
    FUN = function(j) {
      df <- lapply(
        X = 1:nrow(conditions),
        FUN = function(i, j) {
          with(conditions,
               get_bias_emim(
                 results = emim_results[[j]][[i]],
                 C = R[i],
                 M = S[i],
                 V = V[i],
                 Im = Im[i],
                 If = If[i]
               ))
        },
        j = j
      ) %>%
        lapply(as.data.frame.list) %>%
        bind_rows()
        # rename(
        #   paste0("bias_C_", mt[[j]]) = "C",
        #   paste0("bias_M_", mt[[j]]) = "M",
        #   paste0("bias_E:Im_", mt[[j]]) = "E.Im",
        #   paste0("bias_E:If_", mt[[j]]) = "E.If",
        #   paste0("bias_Im_", mt[[j]]) = "Im",
        #   paste0("bias_If_", mt[[j]]) = "If"
        # )
      colnames(df) <- paste0("bias_emim_", colnames(df), "_", mt[[j]])
      return(df)
    }
  )

reject_rate <- lapply(
  X = tril_results,
  FUN = function(X){
    pvals <- 
      mapply(
        FUN = function(mat){
          mat[,2]
        },
        mat = X
      ) %>%
      t() %>%
      apply(
        MARGIN = 2,
        FUN = function(x) (x < 0.05) %>% mean()
      )
  }
) %>%
  lapply(as.data.frame.list) %>%
  bind_rows() %>%
  rename(reject_C = "C",
         reject_M = "M",
         reject_Im = "Im",
         reject_If = "If")

conditions <- conditions %>% mutate(bias, reject_rate)
kable(conditions, caption = "Conditions, bias and rejection rates")

point_est_trill <-
  mapply(
    res = tril_results,
    FUN = function(res) {
      mapply(
        mat = res,
        FUN = function(mat)
          mat[, 1]
      ) %>%
        t() %>%
        exp()
    }
  )
pval_est_trill <-
  mapply(
    res = tril_results,
    FUN = function(res) {
      mapply(
        mat = res,
        FUN = function(mat)
          mat[, 2]
      ) %>%
        t()
    }
  )
    
point_est_emim <- 
  mapply(
    FUN = function(res){
      mapply(
        FUN = function(res){
          res$effects
        },
        res = res
      ) %>%
        t()
    },
    res = emim_results
  )
pval_est_emim <- 
  mapply(
    FUN = function(res){
      mapply(
        FUN = function(res){
          res$pval
        },
        res = res
      ) %>%
        t()
    },
    res = emim_results
  )

mapply(
  FUN = function(point_est_trill, point_est_emim, pval_est_trill, pval_est_emim,
                 effects_vec, includeE, Einteraction, includeControl){
    
    plot(point_est_trill[,1], point_est_emim[,1], 
         main = paste("Effects:", 
                      paste(effects_vec, collapse = " "), 
                      ifelse(includeE, paste(" E:", Einteraction), ""),
                      ifelse(includeControl, ", with controls", ", no controls")
                      )
         )
    abline(a = 0, b = 1, col = "red")
    plot(point_est_trill[,2], point_est_emim[,2], 
         main = paste("Effects:", 
                      paste(effects_vec, collapse = " "), 
                      ifelse(includeE, paste(" E:", Einteraction), ""),
                      ifelse(includeControl, ", with controls", ", no controls")
                      )
         )
    abline(a = 0, b = 1, col = "red")
    
    boxplot(
      point_est_trill,
      las = 2,
      horizontal = TRUE,
      main = paste(
        "point est, Effects:",
        paste(effects_vec, collapse = " "), 
        ifelse(includeE, paste(" E:", Einteraction), ""),
        ifelse(includeControl, ", with controls", ", no controls")
      )
    )
    
    boxplot(
      pval_est_trill,
      las = 2,
      horizontal = TRUE,      
      main = paste(
        "pval, Effects:",
        paste(effects_vec, collapse = " "), 
        ifelse(includeE, paste(" E:", Einteraction), ""),
        ifelse(includeControl, ", with controls", ", no controls")
      )
    )
    abline(v = log(0.05), col = "red", lty = 2)
  },
  point_est_trill,
  point_est_emim,
  pval_est_trill,
  pval_est_emim,
  effects_vec,
  conditions$includeE,
  conditions$Einteraction,
  conditions$includeControl
)

## Double check power for E:Im
## Population stratification simulations (don't worry about PS test)
## Repeat each simulation 2000 times to get a narrow enough CI (listed on notion)
## popstrat, could look at if PoO has more false positives if there is a small C effect
## popstrat is not an issue unless there are different E effects
```

